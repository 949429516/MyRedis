1.缓存穿透
	即故意去请求缓存中不存在的数据，导致所有的请求都在数据库上，从而导致数据库异常

解决方案：
	1.利用互斥锁，缓存失效的时候先去获取锁，得到锁再去请求数据库。没有得到锁则休眠一段时间后重试
	2.采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读取数据库更新缓存。需要做缓存预热（项目启动前先加载缓存）操作。
	3.提供一个能迅速判断请求是否有效拦截机制，比如，利用布隆过滤器内部维护一系列合法有效的key迅速判断出请求所带的key是否合法有效。如果不合法则直接返回。
	

2.缓存雪崩
	缓存同一时间大面积失效，这时候又来了一波请求结果都回去访问数据库，从而导致数据库异常

解决方案：
	1.给缓存的失效时间设置一个随机值避免集体失效。cache.set(redis_key, redis_value, 随机时间)
	2.使用互斥锁，但是该方案吞吐量明显下降。
	3.双缓存。使用两个缓存A与B。A的失效时间为20min，B的失效时间不设置。
		a.从缓存A读数据，有则返回
		b.A没有数据，直接从B读数据直接返回，并且异步启动一个更新线程。
		c.更新线程同时更新A和B
